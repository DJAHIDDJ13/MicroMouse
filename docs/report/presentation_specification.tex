\section{Étude du marché} \label{sec:etudeMarche}
Une compétition Micromouse est un évènement durant lequel plusieurs équipes
s'affrontent en opposant leur robot souris, l'objectif étant de résoudre un
labyrinthe le plus rapidement possible.  Ces compétitions sont organisées
depuis la fin des années 1970 et ont lieu un peu partout autour du monde.

\paragraph{Historique et Origine:} Le magazine "IEE Spectrum magazine" est à l'origine de l'apparition des compétitions Micromouse. C'est un magazine anglophone qui vise à couvrir les tendances et avancées majeures dans les domaines des technologies, de l'ingénierie et des sciences. En 1977, le magazine met au défi ses lecteurs en leurs proposant de concevoir et construire un robot "Micromouse". Le robot devait agir selon sa propre logique et résoudre un labyrinthe imaginé par les rédacteurs du magazine IEE Spectrum. 
\\

Cette compétition fut appelée ‘The Amazing Micromouse Competition’. Elle prit place à New York lors de la conférence nationale sur l'informatique en 1979.
Cet évènement fut couvert par de grands médias tels que les chaînes CBS et ABC ainsi que le journal The New York Times. Le grand succès de cette première édition ainsi que sa large médiatisation participa au gain de popularité des compétitions Micromouse pour les années à venir.  En quelques années, le défi des Micromouses était devenu un événement mondial. 
\\

En 1980, le premier concours européen eu lieu à Londres, suivi un an plus tard par un une compétition organisée à Paris. Le Japon a annoncé l'organisation du premier tournoi mondial
de Micromouse qui aura lieu à Tsubaka en août 1985. La même année, l'IEE
(devenue l'Institution of Engineering and Technology) a organisé un concours
international à Londres.  Au début des années 1990 des clubs Micromouse ont
commencé à faire leur apparition au sein des écoles et universités. La "IEE
Micromouse Competition" bénéficie au aujourd'hui d'une grande
popularité auprès des étudiants du domaine informatique ou électronique.
\newpage
    
\fig{pics/old_micromouse.jpg}{16cm}{12cm}
{Ancienne génération de Micromouse (Pacific Northwest National Laborator, 1980)}{mmcomp}

\paragraph{Organistaions des compétitions}
   Au vu du nombre important de compétitions Micromouse ayant lieu chaque année,
certaines règles et conditions peuvent varier d'une compétition à l'autre.
Néanmoins, il existe des éléments généralement communs à toutes les
compétitions : 
\\ 

\begin{itemize}

\item
   Le labyrinthe standard de micromouse mesure environ $2.5m^2$
et consiste en une grille de cellules (matrice) de 16 sur 16. Chaque micromouse
est autorisée à effectuer un certain nombre de recherches afin de déterminer le
chemin le plus court vers l'objectif.  La micromouse devra garder une trace de
sa position, découvrir les murs en explorant le labyrinthe et détecter quand
elle a atteint son objectif (sortie du labyrinthe). \\

\item
   La notation est basée à la fois sur la course la plus rapide et sur le temps
total consommé pour toutes les courses. Les concurrents n'ont pas le droit de
communiquer avec leur micromouse.  Il existe de nombreuses versions de règles
selon la compétition, et il existe un certain nombre de variations mineures sur
la façon dont le score de la souris est déterminé. \\

\end{itemize}

Il existe un plétore de vidéos disponibles sur Internet qui illustrent le déroulement des compétitions Microumouse partout à travers le globe. Certaines de ses vidéos cumulent plusieurs millions de vus.
Ces vidéos ont grandement susictées notres interêt, et nous ont poussées à implementer notre propre version de la Micromouse en tant que projet de synthèse.
\clearpage
\section{Fonctionnalités attendues} \label{sec:foncAttendues}
   Dans la section [\ref{sec:miseEnScenario}] le lecteur peut observer que le
produit proposé fournit plusieurs options ie:fonctionnalités pour tester et
manipuler différentes entités dans les deux environnements, physique et
simulé dans cette section nous allons introduire ces fonctionnalités et
expliquer les cas d'utilisation de ces derniers.

\subsection{Vue d’ensemble du système} \label{sec:vueEns}

\vspace{5mm}
Le produit permet à l'utilisateur de simuler un véhicule autonome se déplaçant 
dans un labyrinthe et en essayant de trancher le point d'arriver, le labyrinthe 
est créé soit manuellement ou en insérant un fichier de configuration, ainsi la 
simulation pourra se lancer et l'utilisateur pourra observer le déplacement de 
la micro mouse et en même temps d'observer le journal et les statistiques de la 
simulation qui sont modifiées et stockées au fur et à mesure de la simulation, 
ainsi que les valeurs des différents composants de l'engin. \\

En outre, l'utilisateur du produit peut modifier le labyrinthe réel et d'y mettre 
le véhicule dedans pour lancer une observation physique, ainsi qu'il pourra voir 
sur sa machine sur un autre logiciel de visualisation le déplacement et les valeurs 
retournées par l'engin. \\

Le schéma suivant illustre le diagramme de cas d'utilisation du produit.


\fig{pics/UC_micromouse.png}{20cm}{12.5cm}
{Le diagramme de cas d'utilisation du système}{UCMicromouse}

\subsection{Services fournis par le produit} \label{sec:serLogiciel}

\paragraph{Simulation :}La simulation offre à l'utilisateur une diversité de choix 
et d'API comme la création du labyrinthe soit avec un fichier de configuration ou 
manuellement et le choix de la complexité de l'algorithme de recherche du plus court chemin, 
en outre l'utilisateur peut visualiser le journal de la simulation et les statistiques 
sur la partie information sur la simulation, finalement l'utilisateur pourra observer 
les valeurs des différents composants de la micro mouse.


\fig{pics/SimGUI.pdf}{17cm}{10cm}{Interface homme-machine pour la simulation}{ihmSim}

\paragraph{Véhicule réel :}Notre système sera réalisé sur un prototype minimisé 
de micromouse appelé quarter-micromouse, le labyrinthe est constitué d'un quadrillage 
de cellules 8×8 de 180 mm de côté avec des murs de 50 mm de haut les souris sont des 
robots complètement autonomes qui doivent trouver leur chemin d'une position de départ 
prédéterminée à la zone centrale du labyrinthe sans aide. La souris doit savoir où elle 
se trouve, découvrir les murs en explorant, cartographier le labyrinthe et détecter quand 
elle a atteint son but. Une fois l'objectif atteint, la souris effectuera généralement des 
recherches supplémentaires dans le labyrinthe jusqu'à ce qu'elle ait trouvé un itinéraire 
optimal du début à la fin. Une fois que l'itinéraire optimal a été trouvé, la souris exécute 
cet itinéraire dans les plus brefs délais. 


\subsection{Fonctionnalités supplémentaires} \label{sec:foncSupplementaires}

\paragraph{Visualisation en temps réel :}La visualisation des résultats au fur et à mesure 
du temps, au moment du lancement du système l'utilisateur peut lancer un logiciel, c'est le 
logiciel de visualisation des résultats de l'expérience, il permet à l'utilisateur de visualiser 
la vue du véhicule et les valeurs des capteurs au fur et à mesure de l'exploration, aussi de 
visualiser le journal de la simulation et les statistiques.

\fig{pics/visLogiciel.png}{15cm}{8cm}
{Maquette du logiciel de visualisation}{visLogiciel}

\paragraph{Multi-véhicule :} Un mini-jeu est mis en place pour les 
deux univers, simulé et réel permettant d'introduire la notion de communication 
entre différents véhicules, le jeu consiste à parcourir toutes les cases du 
labyrinthe et à la fin se situer dans la case d'arriver par un véhicule autonome 
intelligent en évitant les autres véhicules gradient communiquant entre eux. 
Ceci en utilisant les modules déjà abordés tels que la simulation et l'univers réel.

\fig{pics/GamePacman.pdf}{16cm}{10cm}
{Pac-Man avec l'entité micro mouse (Pac-Micro)}{pacMicro}

La figure [\ref{fig:pacMicro}] représente une illustration du mini-jeu, les trois chats représentent 
les gardiens du labyrinthe et le carré noir représente le véhicule intelligent qui 
doit résoudre le labyrinthe en parcourant toutes les cases tout en évitant de croiser un gradient.


\section{Conception globale du projet} \label{sec:conception}
   après avoir illustré les différentes fonctionnalités du système sur la
section [\ref{sec:foncAttendues}], il va falloir expliquer plus en détails
la conception de ces fonctionnalités, en séparent la vue pour l'utilisateur
on masquera les détails techniques informatiques et on illustrera seulement
les composants ou modules fonctionnels, de l'architecturer technique et
logiciel on va présenter les différentes parties techniques nécessaires
permettant de réaliser les fonctionnalités décrites dans la section
précédente [\ref{sec:foncAttendues}]

\subsection{Vue pour l’utilisateur} \label{sec:vueUtil}
   
   Le système offre à l'utilisateur deux choix pour l'exploiter: \\
\begin{enumerate}

   \item Le système réalisé permet à l'utilisateur d'observer le fonctionnement
 et l'évolution de la micro mouse ie:véhicule autonome dans sans monde un 
 labyrinthe de 8x8 [\ref{sec:serLogiciel}] case dans un monde physique, pour 
 but de résoudre ce labyrinthe et trouver le plus court chemin du point de départ au point final; \\

\begin{itemize}
   \item \textbf{Le labyrinthe} est un carré de 1,44 m2 de surface composé de seize 
« cellules » carrées de 180 millimètres de côté et de 50 millimètres de haut. 
Il peut y avoir 8×8 cellules. \\

   \item \textbf{Le robot} ne doit pas faire plus de 250 millimètres de large 
et de long (il n’y a pas de hauteur limite).
\end{itemize}

   \item Le système permet aussi de simuler les fonctionnalités physiques 
dans un monde simulé, un labyrinthe de taille variante et des chemins à 
définir par l'utilisateur, aussi on peut charger un fichier de configuration 
pour créer le labyrinthe; \\

\begin{itemize}
   \item \textbf{Le labyrinthe} peut être créé par l'utilisateur manuellement 
   ou bien en passant un fichier de configuration.\\

   \item \textbf{Le robot} Le robot est défini comme une entité qui se déplace dans le labyrinthe, il est sous la forme d'un cercle, surface du cercle ne dépasse pas la surface d'une case du labyrinthe.\\
\end{itemize}
\end{enumerate}

   Finalement, l'utilisateur peut observer en temps réel l'évolution 
de la micro mouse dans son univers, cette partie permet aussi d'afficher 
les valeurs des différents composants du véhicule comme les capteurs infrarouges 
et l'accéléromètre ainsi que d'autres informations sur la simulation. \\

\subsection{Architecture technique} \label{sec:archTechnique}

   la micromouse sera composée de nombreuses parties electronique qui vont lui
permettent de fonctionner. \\


   Le plus important d'entre eux est le \textbf{PCB} (Printed Circuit Board)
qui est le corps où tous les autres composants seront soudés, il sert aussi
à les interconnecter et  leur faire communiquer. Pour cela, nous avons
trouvé un design open source \cite{Bulebule:1} conçu pour les micro-souris
qui contient tous les modules nécessaires pour notre produit final. \\


\fig{pics/PCBparts.pdf}{14cm}{10cm}{digramme de composantes dans le PCB}{pcb}


   Le cerveau de notre véhicule sera un micro contrôleur \textbf{STM32F103}
\cite{Bluepill:1} également connu sous le nom de Blue Pill, il a 64KB/128KB de
mémoire flash et 20KB de RAM fonctionnant à 72MHz. \\


   On passe ensuite aux capteurs, qui sont les composants utilisés pour
recevoir les informations du monde extérieur, qui est dans ce cas le
labyrinthe. \\


   Il y a trois types que nous allons utiliser, le premier est le
\textbf{gyroscope} qui est employé pour détecter le changement de direction
et l'angle de rotation, c'est important pour bien tracer le labyrinthe
puisque le véhicule devra faire beaucoup de manœuvres dans le labyrinthe. \\


   Ensuite, il y a \textbf{l'accéléromètre} qui, comme son nom l'indique,
détecte l'accélération, et avec le gyroscope il peut trouver la position ou
plutôt les changements de position, de micromouse, ce capteur alors sera le
seul moyen de localisation pour notre véhicule.\\


   Ces deux capteurs précédents sont généralement regroupés sur une seule
circuit électronique parce qu'ils sont sovent utilisés ensemble et ont des
fonctionnalités similaires, cela nous économise également de la place sur le
PCB. \\


   Enfin, il y a les \textbf{capteurs infrarouge} que nous utiliserons pour
obtenir la distance du véhicule des murs et autres obstacles, ils seront
placés sur toutes les directions pour évaluer plus précisément les alentours
et avoir une meilleure cartographie du labyrinthe. \\


   Nous disposerons également d'un \textbf{module bluetooth}, l'outil de
communication principal.  Lequel est utilisé pour envoyer des données en
direct à l'interface afin de déboguer et de visualiser le processus de
Mapping, ainsi que pour communiquer avec le simulateur de labyrinthe pour
recevoir les signaux des capteurs artificiels. \\


   Le contrôle du véhicule se fera avec deux \textbf{moteurs falhaber}
\cite{faulhaber:1} des deux côtés du véhicule. Les roues et leurs essieux sont
imprimés en 3d pour s'adapter au design du circuit. Aucun volant ne sera
utilisé à cause du poids supplémentaire qu'ils apportent et aussi parce que
les deux que nous avons déjà peuvent faire des manœuvres très précises avec un
code conducteur minimal. \\


   Il existe d'autres petits composants électriques ou \textbf{SMD}s (Surface
Mount Devices) tels que les résistances, condensateurs, interrupteurs,
diodes, LEDs etc... qui sont utilisés pour contrôler le courant électrique
sur le PCB.

\subsection{Architecture logicielle} \label{sec:vueLogicielle}

\paragraph{Contrôle du véhicule :}à un moment de la simulation notre véhicule 
va décider de faire des virages, des marches arrière ...etc., des prises de 
décisions floues. \\

   Pour gérer ça on utilise la logique floue. La logique floue (fuzzy logic, en anglais) 
est une logique polyvalente où les valeurs de vérité des variables - au lieu d'être 
vrai ou faux - sont des réels entre 0 et 1. En ce sens, elle étend la logique booléenne 
classique avec des valeurs de vérités partielles1. Elle consiste à tenir compte de divers 
facteurs numériques pour aboutir à une décision qu'on souhaite acceptable. \\

\paragraph{Mappage et navigation :} Le véhicule a le droit de faire un repérage du labyrinthe 
pour déterminer le chemin vers le point d'arrivée, puis de retourner au point de départ pour 
réaliser l'épreuve en utilisant le chemin le plus court qu'elles ont déterminé.

Ce qui nous introduit au mappage et navigation du véhicule ie:La localisation 
et cartographie simultanées; La localisation et cartographie simultanées connue en 
anglais sous le nom de SLAM (simultaneous localization and mapping) ou CML (concurrent mapping 
and localization), consiste, pour un robot ou véhicule autonome, à simultanément construire ou 
améliorer une carte de son environnement et de s’y localiser.

\paragraph{Calcul du plus court chemin :}après avoir fait le mappage le robot se place sur la 
case départ, en le relançant le robot ne va pas refaire les mêmes pas il va calculer le plus court 
chemin entre la case de départ et la case d'arriver en utilisant toutes les données récupérer à 
l'étape de mappage et en utilisant un algorithme de calcul de plus court chemin. \\

   En théorie des graphes, le problème de plus court chemin est le problème algorithmique qui 
consiste à trouver un chemin d'un sommet à un autre de façon que la somme des poids des arcs de ce chemin soit minimale. \\

\paragraph{Communication :}Pour déboguer et visualiser les données du véhicule ou bien pour recevoir les signaux artificiels des capteurs de la simulation une communication entre les composants est nécessaire, ainsi le transfert de données se fait en temps réel.

\fig{pics/pbSchema.png}{14cm}{10cm}
{schéma illustrant l’enchaînement des différentes parties}{pbSchema}

\section{Problématiques identifiées et solutions envisagées} \label{sec:problemesSolutions}
   D'un coup d'œil, plusieurs problèmes majeurs se posent d'un point de vue
technique du projet.  Dans cette section, nous décrivons ces problèmes et
les solutions que nous y apportons.


   Pour notre véhicule, les seules données qu'il reçoit du monde extérieur sont
celles des capteurs, ce sont des signaux en temps réel des changements de
rotation et d'accélération, ainsi que les distances des murs qui sont les
principales informations que nous allons utiliser pour le traçage de la mappe. \\

   Pour transformer ces signaux en une carte 2D du labyrinthe, nous allons devoir
commencer par déterminer la position et la direction du véhicule. Pour cela,
nous utiliserons les informations du gyroscope afin de garder une copie de la
position et de la direction et de les actualiser a chaque iteration en
utilisant les données reçues. \\

   Après avoir obtenu ces entrées, nous allons les utiliser avec les informations
restantes des capteurs infrarouges pour faire la mappage proprement dite, nous
pouvons utiliser un algorithme de Flood fill pour déterminer la géométrie des
murs et/ou des obstacles. Après un peu de nettoyage et interpolation nous
devrions avoir une carte finale du labyrinthe. \\

   Une fois le tour de mapping est terminé, nous devrons trouver le chemin le plus
court entre la position du véhicule et le point d'arrivée. Une solution qui
vient à l'esprit est l'algorithme A* qu'il est souvent utilisé dans les
labyrinthes et qui est alors idéale pour notre projet. Bien sûr, l'algorithme
doit être modifié pour tenir compte des erreurs occasionnelles de contrôle qui
surviennent à cause des irrégularités du monde physique.

\fig{pics/FloodAlg.png}{7cm}{7cm}
{Algorithme de Flood fill, Micromouse competition US 1982}{floodalg}

\subsection{Contrôle du véhicule} \label{sec:ctrlComm}

Notre véhicule se compose de deux moteurs que nous devrons contrôler pour
parcourir les chemins avec fluidité, il devra faire des virages et éviter les
collisions avec les murs et autres obstacles, tout en suivant le chemin créé
pour lui. \\

Pour résoudre ces problèmes, nous allons utiliser la logique floue qui servira
à générer des signaux pour les puissances des moteurs en temps réel. La façon
dont cela fonctionne est que nous créons un moteur d'inférence et lui
fournissons des règles qui décrivent la façon dont la véhicule doit se comporter 
en se déplaçant, et le moteur utilisera ces règles ainsi que les données du
capteurs pour générer les signaux de sortie des moteurs qui seront sa décision
finale.

\subsection{Communication} \label{sec:mapMaze}
Un problème qui se pose à cause des besoins de certaines fonctionnalités du
projet est la communication, que ce soit pour déboguer et visualiser les
données du véhicule ou bien pour recevoir les signaux artificiels des capteurs
de la simulation. \\

Tous deux auront besoin de leur propre protocole de communication respectif
à être efficaces, fiables et rapides puisque le transfert de données se fait en
temps réel, avec les ressources limitées de micro contrôleur. et pour cela nous
allons utiliser une communication serial entre le module Bluetooth de Micromouse
et les autres parties communicantes.

\subsection{Génération du labyrinthe}
Le labyrinthe constitue un élément import du projet, ce dernier représente l’environnement externe dans lequelle va se mouvoir notre Micromouse. Il existe un certain nombre de problématiques liées à la construction de notre labyrinthe. Des problématiques logiques : Quel algorithme utiliser afin de générer notre labyrinthe ? Quelle sont les spécificités architecturales que notre labyrinthe devra respectre ? 
Ainsi que des problématique liées au monde physique : Quel matériaux utiliser pour la construction de notre labyrinthe ? (prendre en compte l’adhérence avec les roues de la Micromouse).
\subsection{Mappage et navigation} \label{sec:rechChem} 

\section{Environnement de travail} \label{sec:environnement}
   Plusieurs outils et matériels ont été utilisés pour développer les
différents composants de la micromouse. Ici ils sont décrits et leurs rôles
dans la réalisation de chacune de ces parties.

\subsection{logiciels et environnements de développement} \label{subsec:softDev} 

   Le simulateur de labyrinthe et l'interface temps réel de la micro mouse sont
écrits en langage de programmation Processing. Le contrôleur principal de
l'Arduino est écrit en C. \\


   \textbf{Processing} est un langage qui se concentre sur les graphiques et
les interfaces 2D et 3D, il sera utilisé pour créer des courbes et des
animations en temps réel très claires et informatives, ainsi que des
contrôles simples et faciles à utiliser. il fournit des bibliothèques pour
la communication serial pour le transfert de signals depuis et vers le micro
contrôleur. \\

 
   Le \textbf{IDE} \footnote{Integrated Development Environment}
\textbf{Processing} nous permettra d'organiser le projet, etd'exécuter le
code de Processing.  Il a également un débogueur intégré etd'autres
outils de developpement, et une interface simple pour ajouter
les bibliothèques et extensions de langage. \\ 


   \textbf{Box2D} est une librairie de simulation physique 2D écrite pour C++,
mais il existe des frameworks et wrappers pour cela en Java et Processing.
elle sera utilisée pour simuler le véhicule et ses interactions avec son
environnement. et pour générer en temps réel des signaux de capteurs
artificiels pour tester la micro souris. \\

\fig{pics/Box2dScreenshot.png}{10cm}{10cm}{Exemple d'usage de Box2D, Wikimedia creative commons}{box2dscrn}

   Le \textbf{IDE Arduino} sera utilisé pour développer le microcontrôleur
principal en C, il dispose d'outils qui permettent la compilation et
l'ectiture des sorties binaires dans le micro contrôleur. \\

\subsection{Matériel informatique} \label{subsec:hardDev}
Dans ce projet, nous avions une carte de circuit imprimé utilisée pour
connecter les pièces de notre véhicule, celle qui devait être imprimée à l'aide
d'une \textbf{imprimante PCB} qui grave les circuits de la carte pour pouvoir
ensuite souder les pièces ensemble. Nous avons également des pièces qui
nécessitent une \textbf{imprimante 3D} pour fabriquer les formes des roues et
essieux du véhicule pour qu'ils s'adaptent au design du corps.    